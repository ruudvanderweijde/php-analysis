diff --git a/src/lang/php/types/TypeConstraints.rsc b/src/lang/php/types/TypeConstraints.rsc
index f319dac..1981448 100644
--- a/src/lang/php/types/TypeConstraints.rsc
+++ b/src/lang/php/types/TypeConstraints.rsc
@@ -3,48 +3,36 @@ module lang::php::types::TypeConstraints
 import lang::php::ast::AbstractSyntax;
 import lang::php::types::TypeSymbol;
 
-//alias TypeFacts = rel[loc decl, Fact fact];
-
-// these facts can be extracted from the M3.
-//data Fact
-//	= className(str name) // = FQN (= fully qualified name) 
-//	| classMethod(str name)
-//	| classProperty(str name)
-//	| classConstant(str name)
-//	| classConstructorParameters(PhpParams params)
-//	| methodName(str name)
-//	| methodParameters(PhpParams params)
-//	| functionName(str name) 
-//	| functionParameters(PhpParams params)
-//	;
-
-data TypeOf 
+data TypeOfA
 	= typeOf(loc ident)
-	| typeOf(TypeSymbol ts)
-	| arrayType(set[TypeOf] expressions)
+	| typeSymbol(TypeSymbol ts)
+	| \function(loc ident)
+	| var(loc decl)
+	| arrayType(set[TypeOfA] expressions)
 	;
 
 data Constraint 
-	= eq(TypeOf a, TypeOf t)
-	| eq(TypeOf a, TypeSymbol ts)
-    | subtyp(TypeOf a, TypeOf t)
-    | subtyp(TypeOf a, TypeSymbol ts)
-    | supertyp(TypeOf a, TypeOf t)
-    | supertyp(TypeOf a, TypeSymbol ts)
+	= eq(TypeOfA a, TypeOfA t)
+	| eq(TypeOfA a, TypeSymbol ts) // are rewritten to typeSymbol(ts)
+	//| lub(TypeOfA a, TypeOfA t)
+    | subtyp(TypeOfA a, TypeOfA t)
+    | subtyp(TypeOfA a, TypeSymbol ts)
+    | supertyp(TypeOfA a, TypeOfA t)
+    | supertyp(TypeOfA a, TypeSymbol ts)
  
  	// kind of like 'typeEnvironment' 
   	//| varDecl(rel[loc declaration, loc location] decl)
   	
    	// query the m3 to solve these 
-    | isAFunction(TypeOf a)
-    | isAMethod(TypeOf a)
-    | hasName(TypeOf a, str name)
+    | isAFunction(TypeOfA a)
+    | isAMethod(TypeOfA a)
+    | hasName(TypeOfA a, str name)
     
-    | isItemOfClass(TypeOf a, TypeOf t)
-    | hasMethod(TypeOf a, str name)
-    | hasMethod(TypeOf a, str name, set[ModifierConstraint] modifiers)
-    //| parentHasMethod(TypeOf a, str name)
-    //| parentHasMethod(TypeOf a, str name, set[ModifierConstraint] modifiers)
+    | isItemOfClass(TypeOfA a, TypeOfA t)
+    | hasMethod(TypeOfA a, str name)
+    | hasMethod(TypeOfA a, str name, set[ModifierConstraint] modifiers)
+    //| parentHasMethod(TypeOfA a, str name)
+    //| parentHasMethod(TypeOfA a, str name, set[ModifierConstraint] modifiers)
     
     | conditional(Constraint preCondition, Constraint result)
     | disjunction(set[Constraint] constraints)
@@ -58,9 +46,9 @@ data ModifierConstraint
 	| notAllowed(set[Modifier] modifiers)
 	;
 
-//
-// do not use typesets (can be added later to boost performance of solving constraints)
-//
+alias TypeEnv = map[TypeOfA, TypeSet];
+alias TypeHierarchy = rel[TypeSymbol, TypeSymbol];
+
 data TypeSet
 	= Universe()
 	| EmptySet()
@@ -68,42 +56,98 @@ data TypeSet
 	| Single(TypeSymbol T)
 	| Set(set[TypeSymbol] Ts)
 	| Subtypes(TypeSet subs)
-	| Supertypes(TypeSet subs)
+	| Supertypes(TypeSet supers)
 	| Union(set[TypeSet] args)
 	| Intersection(set[TypeSet] args)
-	| LUB(set[TypeSet] args) // actually least common ancestor
+	| LCA(set[TypeSet] args) // actually least common ancestor
 	;
 	
 TypeSet Set({\any()})        = Root();
 TypeSet Set({})              = EmptySet();
 TypeSet Single(TypeSymbol T) = Set({T});
 
-TypeSet Subtypes(Root())              = Universe();
+TypeSet Subtypes(Root())	          = Universe();
 TypeSet Subtypes(EmptySet())          = EmptySet();
 TypeSet Subtypes(Universe())          = Universe();
 TypeSet Subtypes(Subtypes(TypeSet x)) = Subtypes(x);
 
-TypeSet Intersection ({x}) = x;
-//TypeSet Intersection ({Subtypes(TypeSet x), x, set[TypeSet] rest}) 
-//	= Intersection (Subtypes(x), rest);
-TypeSet Intersection ({EmptySet(), set[TypeSet] _}) = EmptySet();
-TypeSet Intersection ({Universe(), set[TypeSet] x}) = Intersection({x});
-TypeSet Intersection ({Set(_), EmptySet()}) = EmptySet();
-TypeSet Intersection ({x:Set(_), Universe()}) = Intersection({x});
-TypeSet Intersection ({Set (set[TypeSymbol] t1), Set (set[TypeSymbol] t2), set[TypeSet] rest}) 
-	= Intersection ({Set (t1 & t2), rest});
+TypeSet Supertypes(Root())	            = Single(\any());
+TypeSet Supertypes(EmptySet())          = EmptySet();
+TypeSet Supertypes(Universe())          = Universe();
+TypeSet Supertypes(Supertypes(TypeSet x)) = Supertypes(x);
+TypeSet Supertypes(TypeSet x) 			= Supertypes(x);
 
-TypeSet Union({x}) = x;
-TypeSet Union({Universe(), Set(_)}) = Universe();
-TypeSet Union({EmptySet(), Set(x)}) = Union({x});
-TypeSet Union({Set(set[TypeSymbol] t1), Set (set[TypeSymbol] t2), set[TypeSet] rest}) 
-	= Union({Set(t1 + t2), rest});	
-	
-TypeSet LUB({x}) = x;
-TypeSet LUB({EmptySet(), set[TypeSet] _}) = EmptySet();
-TypeSet LUB({Universe(), set[TypeSet] x}) = Intersection({x});
-TypeSet LUB({Set(set[TypeSymbol] t1), Set (set[TypeSymbol] t2), set[TypeSet] rest}) 
-	= LUB({Set(LCA(t1, t2)), rest});	
-	
-TypeSet LCA(Set(set[TypeSymbol] t1), Set (set[TypeSymbol] t2)) =
-	t1;
\ No newline at end of file
+TypeSet Intersection({})               = EmptySet();
+TypeSet Intersection({x})              = x;
+TypeSet Intersection({Universe(), *x}) = Intersection(x);
+TypeSet Intersection({EmptySet(), _*}) = EmptySet();
+TypeSet Intersection({(), _*}) = EmptySet();
+TypeSet Intersection({Set(set[TypeSymbol] t1), Root()}) = Intersection({Set(t1 & { \any() } )});
+TypeSet Intersection({Set(set[TypeSymbol] t1), Set(set[TypeSymbol] t2), rest*}) =
+	Intersection({Set(t1 & t2), *rest});	
+
+TypeSet Union({})                  = EmptySet();
+TypeSet Union({x})                 = x;
+TypeSet Union({Universe(), _*})    = Universe();
+TypeSet Union({EmptySet(), *x})    = Union(x);
+TypeSet Union({Set(set[TypeSymbol] t1), Root()}) = Union({Set(t1 + { \any() })});
+TypeSet Union({Set(set[TypeSymbol] t1), Set(set[TypeSymbol] t2), rest*}) =
+	Union({Set(t1 + t2), *rest});	
+
+// LCA DOES NOT WORK PROPERLY YET!
+TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {})                  = EmptySet();
+TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {Universe(), *x})    = LCA(subtypes, x);
+TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {EmptySet(), *x})    = LCA(subtypes, x);
+TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {Set(set[TypeSymbol] t1), Root()}) = LCA(subtypes, {Set(t1 + { \any() })});
+//TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {Set(set[TypeSymbol] t1)}) = LCA(subtypes, {Set({shortestPathPair(subtypes, t1, \any())[0]})});	
+//list[TypeSymbol] LCA({ rel[TypeSymbol, TypeSymbol] subtypes, TypeSet t1, *rest }) 
+//{
+//println("b");
+//	type1 = [];
+//	for (t <- t1) {
+//		type1 += shortestPathPair(subtypes, t, \any());	
+//	}
+//	return type1;
+//	//return LCA(subtypes, {Set({type1[0]})});	
+//}
+//list[TypeSymbol] LCA(rel[TypeSymbol, TypeSymbol] subtypes, Set(set[TypeSymbol] t1)) 
+//{
+//println("c");
+//	type1 = [];
+//	for (t <- t1) {
+//		type1 += shortestPathPair(subtypes, t, \any());	
+//	}
+//	return type1;
+//	//return LCA(subtypes, {Set({type1[0]})});	
+//}
+//TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, Set(set[TypeSymbol] t1), *rest) 
+//{
+//	type1 = [];
+//	for (t <- t1) {
+//		type1 += shortestPathPair(subtypes, t, \any());	
+//	}
+//	if (!isEmpty(rest)) 
+//		return LCA(subtypes, {Set({( type1 & LCA(subtypes, rest))[0]})});	
+//	else 
+//		return LCA(subtypes, {Set({type1[0]})});	
+//}
+////TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, {Set(set[TypeSymbol] t1), rest*}) = LCA(subtypes, {Set({(shortestPathPair(subtypes, t1, \any()) & LCA(subtypes, rest))[0]})});	
+//
+//list[TypeSymbol] LCA(rel[TypeSymbol, TypeSymbol] subtypes, { TypeSymbol t1 }) = shortestPathPair(subtypes, t1, \any());
+//list[TypeSymbol] LCA(rel[TypeSymbol, TypeSymbol] subtypes, { TypeSymbol t1, *rest }) = shortestPathPair(subtypes, t1, \any()) + LCA(subtypes, rest);	
+////TypeSet LCA(rel[TypeSymbol, TypeSymbol] subtypes, TypeSet x)                 = x;
+
+//TypeSet LCA({x}) = x;
+//TypeSet LCA({Universe(), Set(x)}) = LCA({x});
+//TypeSet LCA({EmptySet(), Set(x)}) = LCA({x});
+//TypeSet LCA({Set(t1), Set(t2)})   = LCA({Set(t1 + t2)});	
+//TypeSet LCA({t1, t2, rest})       = LCA({ LCA({t1,t2}), rest});	
+
+//public TypeHierarchy subtypes = {};
+//
+//@memo
+//public TypeHierarchy getSubTypes() {
+//	if (isEmpty(subtypes)) throw "please initalize subtype relation first";
+//
+//	return subtypes;
+//}
